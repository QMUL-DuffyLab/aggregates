module agg
  use curand_device
  use cudafor
  use iso_c_binding
  implicit none
  integer, parameter :: dp = c_double
  integer, parameter :: short = c_short
  integer, parameter :: ip = c_int
  real, parameter :: pi = 3.1415926535
  logical :: pool_pq_ann

  contains

    attributes(device) function randint(h, upper) result(res)
      implicit none
      type(curandStateXORWOW) :: h
      integer :: res, upper
      real :: r
      r = curand_uniform(h)
      do while (r.eq.0.0)
        r = curand_uniform(h)
      end do
      res = ceiling(upper * r)
    end function randint

    attributes(global) subroutine gpu_init(q, n_sites, n_quenchers,&
      n_bins, sample_offset)
      implicit none
      integer :: q(n_quenchers, *)
      integer, value :: n_sites, n_quenchers, n_bins, rate_size, sample_offset
      integer, shared :: n_i(n_sites), n_pq(n_sites), n_q(n_sites)
      logical, shared :: is_quencher(n_sites)
      integer, shared :: quenchers(n_quenchers), block_counts(4, n_bins)
      ! real, shared :: base_rates(n_sites * rate_size)
      type(curandStateXORWOW) :: h
      integer(8) :: seed, seq, offset
      integer :: iam, ib, set_q, choice
      
      n_i = 0
      n_pq = 0
      n_q = 0
      quenchers = 0
      is_quencher = .false.
      block_counts = 0

      ! each sample should be given a unique seed
      ! and each thread a unique sequence number
      iam = threadIdx%x
      seed = sample_offset * 64 + 12345
      seq = iam + (blockIdx%x * blockDim%x)
      offset = 0
      call curand_init(seed, seq, offset, h)

      ! set n_quenchers of the sites as quenching sites randomly per block
      set_q = 0
      do while ((n_quenchers - set_q).gt.0)
        if (iam.le.(n_quenchers - set_q)) then
          choice = randint(h, n_sites)
          do while (is_quencher(choice))
            choice = randint(h, n_sites)
          end do
          is_quencher(choice) = .true.
          quenchers(iam) = choice
        end if
        ! different threads might have picked the same site
        call syncthreads()
        set_q = count(is_quencher)
      end do

      ib = blockIdx%x
      if (iam.le.n_quenchers) then
        q(iam, ib) = quenchers(iam)
      end if

      ! rates = get_rates(iam, t, rate_type)

    end subroutine gpu_init

    attributes(host) subroutine check_stats(grid_size, n_iter)
      implicit none
      ! real, allocatable, constant :: base_rates(:)
      integer :: n_sites, n_quenchers, n_bins, i, j, share,&
        grid_size, n_iter
      real :: start_time, end_time, mean, var, residue
      ! integer :: counts(n_bins)
      integer, dimension(:, :), allocatable, device :: quenchers_d
      integer, dimension(:, :), allocatable :: quenchers
      real, dimension(:, :), allocatable :: q_sum
      type(dim3) :: grid, tBlock

      call cpu_time(start_time)

      n_sites = 100
      n_quenchers = 10
      n_bins = 100
      tBlock = dim3(256,1,1)
      ! grid = dim3(ceiling(real(512)/tBlock%x),1,1)
      grid = dim3(grid_size,1,1)
      share =  4 * ((4 * n_sites) + n_quenchers + (4 * n_bins))
      mean = (1.0 / 2.0) * (n_sites + 1)
      ! this is the expected variance of each
      ! quencher array after 10000 iterations
      var = (1.0 / (12.0 * n_quenchers * n_iter)) * (n_sites - 1)**2

      allocate(quenchers_d(n_quenchers, grid%x))
      allocate(quenchers(n_quenchers, grid%x))
      allocate(q_sum(n_quenchers, grid%x))
      q_sum = 0.0
      do i = 1, n_iter
        quenchers = 0
        call gpu_init<<<grid, tBlock, share>>>(quenchers_d, n_sites,&
          n_quenchers, n_bins, i - 1)
        quenchers = quenchers_d
        q_sum = q_sum + float(quenchers)
      end do

      call cpu_time(end_time)
      write(*, *) "Grid size: ", grid%x
      write(*, *) "Total iterations: ", grid%x * n_iter
      write(*, *) "Time elapsed: ", end_time - start_time
      write(*, *) "Time per iteration: ", (end_time - start_time) / float(grid%x * n_iter)
      write (*, *) "Expected mean: ", mean
      write (*, *) "Variance: ", var

      q_sum = q_sum / n_iter
      write(*, *)
      write(*, *) "STATS:"
      write(*, *)
      do i = 1, grid%x
        ! write(*, '(a, I3)') "i = ", i
        residue = 0.0
        do j = 1, n_quenchers
          ! write (*, '(F8.3, a)') q_sum(j, i), " "
          residue = residue + q_sum(j, i)
        end do
        residue = mean - (residue / n_quenchers)
        if ((residue**2).gt.var) then
          write(*, *) "i = ", i, " res = ", residue**2
        end if
      end do

      ! don't think deallocations are actually necessary?
      ! i think fortran does the cleanup for you. check with valgrind
      deallocate(quenchers_d)
      deallocate(quenchers)
      deallocate(q_sum)

    end subroutine check_stats

end module agg

program cuda_agg
  use cudafor
  use agg
  implicit none
  real, allocatable, pinned :: base_rates(:)
  ! integer :: counts(n_bins)
  integer :: grid_size, n_iter, share_size

  ! share_size = 4 * n_sites + 4 * (n_quenchers + &
  !             (4 * n_bins) + (n_sites * rate_size))

  grid_size = 5
  n_iter = 1000
  call check_stats(grid_size, n_iter)

end program cuda_agg
