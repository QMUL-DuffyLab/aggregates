module agg
  use curand_device
  use cudafor
  use iso_c_binding
  implicit none
  integer, parameter :: dp = c_double
  integer, parameter :: short = c_short
  integer, parameter :: ip = c_int
  real, parameter :: pi = 3.1415926535
  logical :: pool_pq_ann

  contains

    attributes(device) function randint(h, upper) result(res)
      implicit none
      type(curandStateXORWOW) :: h
      integer :: res, upper
      real :: r
      r = curand_uniform(h)
      do while (r.eq.0.0)
        r = curand_uniform(h)
      end do
      res = ceiling(upper * r)
    end function randint

    attributes(global) subroutine run_mc(c, dt, t_pulse, max_time, binwidth,&
      pu, br, nb, fluence,&
      n_sites, n_quenchers, n_bins, rate_size, sample_offset)
      implicit none
      integer :: c(4, n_bins)
      integer, value :: n_sites, n_quenchers, n_bins, rate_size, sample_offset
      real, value :: dt, t_pulse, max_time, binwidth, fluence
      real :: br(rate_size * (n_sites + 2))
      real :: pu(int(t_pulse / dt))
      integer(2) :: nb(n_sites, rate_size - 5)
      integer, shared :: n_i(n_sites), n_pq(n_sites), n_q(n_sites)
      logical(1), shared :: is_quencher(n_sites)
      integer(2), shared :: quenchers(n_quenchers)
      integer(2), shared :: block_counts(4, n_bins)
      real, shared :: pulse(int(t_pulse / dt))
      real :: tbr(rate_size)
      integer :: tn(rate_size - 5)
      real, shared :: t
      integer, shared :: n_current
      real :: rates(rate_size), probs(rate_size)
      type(curandStateXORWOW) :: h
      integer(8) :: seed, seq, offset
      integer :: i, j, k, iam
      integer(1) :: rate_type

      if (threadidx%x.gt.int(t_pulse / dt)) then
        pulse(threadidx%x) = pu(threadidx%x)
      ! if we have some tiny number of threads for some reason
      ! then just do this serially, who cares
      else if (threadidx%x.eq.1) then
        do i = 1, int(t_pulse / dt)
          pulse(i) = pu(i)
        end do
      end if
      
      ! each sample should be given a unique seed
      ! and each thread a unique sequence number
      seed = sample_offset * 64 + 12345
      seq = threadidx%x + (blockidx%x * blockdim%x)
      offset = 0
      call curand_init(seed, seq, offset, h)

      ! set n_quenchers of the sites as quenching sites randomly per block
      quenchers = 0
      is_quencher = .false.
      i = 0
      do while ((n_quenchers - i).gt.0)
        if (threadidx%x.le.(n_quenchers - i)) then
          j = randint(h, n_sites)
          do while (is_quencher(j))
            j = randint(h, n_sites)
          end do
          is_quencher(j) = .true.
          quenchers(threadidx%x) = j
        end if
        ! different threads might have picked the same site
        call syncthreads()
        i = count(is_quencher)
      end do

      ! get the base rates and list of neighbours per thread
      if (threadidx%x.le.n_sites) then
        i = ((threadidx%x - 1) * rate_size) + 1
        j = i + rate_size - 1
        k = threadidx%x
        rate_type = 1
      else if ((threadidx%x.gt.n_sites).and.&
        (threadidx%x.le.(n_sites + n_quenchers))) then
        i = ((n_sites) * rate_size) + 1
        j = i + rate_size - 1
        k = quenchers(threadidx%x - n_sites)
        rate_type = 2
      else if ((threadidx%x.gt.(n_sites + n_quenchers)).and.&
        (threadidx%x.le.(n_sites + 2 * n_quenchers))) then
        i = ((n_sites + 1) * rate_size) + 1
        j = i + rate_size - 1
        k = quenchers(threadidx%x - (n_sites + n_quenchers))
        rate_type = 3
      end if
      
      tbr = br(i:j)
      tn  = nb(k, :)
      ! zero the pool -> pq rate if this trimer's not a quencher
      ! this way we don't have to check it in get_rates
      if ((threadidx%x.le.n_sites).and.(.not.is_quencher(k))) then
        tbr(size(tbr) - 2) = 0.0
      end if
          

      if (threadidx%x.eq.1) then
        n_i = 0
        n_pq = 0
        n_q = 0
        block_counts = 0
        n_current = 0
        t = 0.0
      end if
      call syncthreads()

      do while (t.lt.t_pulse)
        call mc_step(t, dt, binwidth, rate_type, size(tbr), quenchers,&
          is_quencher, n_i, n_pq, n_q, pulse,&
          n_current, tbr, tn, block_counts, h)
        call syncthreads()
        if (threadidx%x.eq.1) then
          t = t + dt
        end if
      end do
      do while ((n_current.gt.0).and.(t.lt.max_time))
        call mc_step(t, dt, binwidth, rate_type, size(tbr), quenchers,&
          is_quencher, n_i, n_pq, n_q, pulse,&
          n_current, tbr, tn, block_counts, h)
        call syncthreads()
        if (threadidx%x.eq.1) then
          t = t + dt
        end if
      end do

      if (threadidx%x.eq.1) then
        do i = 1, n_bins
          do j = 1, 4
            k = atomicadd(c(j, i), int(block_counts(j, i)))
          end do
        end do
        write (*, *) "block ", blockidx%x, " finished"
      end if

    end subroutine run_mc

    attributes(device) subroutine mc_step(t, dt, binwidth, rate_type,&
      rate_size, quenchers, is_quencher, n_i, n_pq, n_q, pulse,&
      n_current, tbr, tn, block_counts, h)
      implicit none
      integer, value :: rate_size
      real, value :: t, dt, binwidth
      integer, dimension(:) :: n_i, n_pq, n_q, tn
      integer(2), dimension(:) :: quenchers
      integer(2), dimension(:, :) :: block_counts
      real :: rand, rates(rate_size)
      real, dimension(:) :: tbr, pulse
      integer :: i, j, k, istat, ri, n_current, n_sites, n_moves
      integer, shared :: losses(4)
      integer(1) :: rate_type
      logical(1) :: is_quencher(n_sites)
      type(curandStateXORWOW) :: h
      n_sites = size(n_i)

      if (rate_type.eq.1) then
        i = threadidx%x
      else if (rate_type.eq.2) then
        i = quenchers(threadidx%x - n_sites)
      else if (rate_type.eq.3) then
        i = quenchers(threadidx%x - (n_sites + size(quenchers)))
      end if

      if (t <= size(pulse) * dt) then
        n_moves = 4
      else 
        n_moves = 3
      end if
      ! four possible moves: generation, hop, decay, annihilation
      losses = 0
      do j = 1, n_moves
        ! pick at random - stats
        ri = randint(h, n_moves)
        rates = get_rates(tbr, t, dt, rate_type, quenchers,&
          n_i, n_pq, n_q, pulse, is_quencher)
        rates = [(rates(k) * exp(-1.0 * rates(k) * dt), &
          k = 1, size(tbr))]

        ! generation rate is the first one in the list of rates
        ! but it's easier to just make it no. 4 here - that
        ! way we can pick from 1 to n_moves and only get generation
        ! if t < t_pulse. not very intuitive though :|
        select case (ri)
          case (1) ! hop
            k = randint(h, size(rates) - 3) + 1
          case (2) ! decay
            k = size(rates) - 1
          case (3) ! annihilation
            k = size(rates)
          case (4) ! gen
            k = 1
        end select

        if (rates(k).gt.0.0) then
          rand = curand_uniform(h)
          if (rand.lt.rates(k)) then
            call move(i, k, losses, rate_type, size(rates),&
              n_i, n_pq, n_q, tn, n_current, is_quencher, h)
          end if
        end if

        ! population on each site might have changed
        call syncthreads()

      end do

      if (threadidx%x.eq.1) then
        do k = 1, size(losses)
          block_counts(k, floor(t / binwidth) + 1) = (&
            block_counts(k, floor(t / binwidth) + 1) + losses(k))
        end do
      end if

      call syncthreads()

    end subroutine mc_step

    attributes(device) subroutine move(ind, process, losses, rate_type,&
        rate_size, n_i, n_pq, n_q, tn, n_current, is_quencher, h)
      implicit none
      integer(1) :: rate_type
      integer :: ind, process, k, nn, istat, choice,&
        n_sites, rate_size, n_current
      integer, dimension(:) :: n_i, n_pq, n_q, losses
      integer, dimension(:) :: tn
      logical(1) :: pop_loss(4), is_quencher(n_sites)
      type(curandStateXORWOW) :: h

      n_sites = size(n_i)
      if (rate_type.eq.1) then
        ! normal trimer
        if (process.eq.1) then
          ! generation
          n_i(ind) = n_i(ind) + 1
          istat    = atomicadd(n_current, 1)
          ! write(*,*) "gen"
        else if ((process.gt.1).and.(process.lt.(rate_size - 3))) then
          ! hop to neighbour. -1 because of the generation rate
          nn    = tn(process - 1)
          istat = atomicsub(n_i(ind), 1)
          istat = atomicadd(n_i(nn),  1)
          ! write(*,*) "hop"
        else if (process.eq.rate_size - 3) then
          ! there will always be an empty rate due to
          ! there being an extra possible process on pq
          continue
          ! write(*,*) "FORBIDDEN MOVE"
        else if (process.eq.rate_size - 2) then
          ! hop to pre-quencher
          n_i(ind) = n_i(ind) - 1
          n_pq(ind) = n_pq(ind) + 1
          ! write(*,*) "po-pq"
        else if (process.eq.rate_size - 1) then
          ! decay
          n_i(ind)   = n_i(ind) - 1
          istat = atomicsub(n_current,  1)
          istat = atomicadd(losses(2), 1)
          ! write(*,*) "pool decay"
        else if (process.eq.rate_size) then
          ! annihilation
          ! if this is a quencher, pool excitons can
          ! annihilate with pq excitons. this assumes
          ! the pre-quencher is always another chl!
          if (is_quencher(ind)) then
            choice = randint(h, int(n_pq(ind) + n_i(ind)))
            if (choice.eq.n_pq(ind)) then
              n_pq(ind) = n_pq(ind) - 1
            else
              n_i(ind) = n_i(ind) - 1
            end if
          else
            n_i(ind) = n_i(ind) - 1
          end if
          istat = atomicsub(n_current, 1)
          istat = atomicadd(losses(1), 1)
          ! write(*,*) "pool ann"
        end if
      else if (rate_type.eq.2) then
        ! pre-quencher
        if (process.eq.1) then
          ! generation
          n_pq(ind) = n_pq(ind) + 1
          istat     = atomicadd(n_current, 1)
          ! write(*,*) "pq gen"
        else if (process.eq.(rate_size - 3)) then
          ! hop back to pool trimer
          n_pq(ind) = n_pq(ind) - 1
          n_i(ind)  = n_i(ind) + 1
          ! write(*,*) "pq-po"
        else if (process.eq.rate_size - 2) then
          ! hop to quencher
          n_pq(ind) = n_pq(ind) - 1
          n_q(ind)  = n_q(ind) + 1
          ! write(*,*) "pq-q"
        else if (process.eq.rate_size - 1) then
          ! pq decay
          n_pq(ind)  = n_pq(ind) - 1
          istat = atomicsub(n_current, 1)
          istat = atomicadd(losses(3), 1)
          ! write(*,*) "pq decay"
        else if (process.eq.rate_size) then
          ! annihilation
          choice = randint(h, n_pq(ind) + n_i(ind))
          if (choice.eq.n_pq(ind)) then
            n_pq(ind) = n_pq(ind) - 1
          else
            n_i(ind)  = n_i(ind) - 1
          end if
          istat = atomicsub(n_current, 1)
          istat = atomicadd(losses(1), 1)
          ! write(*,*) "pq ann"
        end if
      else if (rate_type.eq.3) then
        ! quencher
        if (process.eq.0) then
          ! generation
          n_q(ind) = n_q(ind) +  1
          istat    = atomicadd(n_current, 1)
          ! write(*,*) "q gen"
        else if (process.eq.(rate_size - 2)) then
          ! hop back to pre-quencher
          n_q(ind)  = n_q(ind) - 1
          n_pq(ind) = n_pq(ind) + 1
          ! write(*,*) "q-pq"
        else if (process.eq.rate_size - 1) then
          ! q decay
          n_q(ind)  = n_q(ind) - 1
          istat = atomicsub(n_current, 1)
          istat = atomicadd(losses(4), 1)
          ! write(*,*) "q decay"
        else if (process.eq.rate_size) then
          ! annihilation
          n_q(ind)  = n_q(ind) - 1
          istat = atomicsub(n_current, 1)
          istat = atomicadd(losses(1), 1)
          ! write(*,*) "q ann"
        end if
      end if
    end subroutine move

    attributes(device) function get_rates(tbr, t, dt,&
      rate_type, quenchers,&
      n_i, n_pq, n_q, pulse, is_quencher) result(rates)
      ! return a set of rates depending on which trimer
      ! we're on and whether it's a quencher etc.
      implicit none
      real, dimension(:) :: tbr, rates, pulse
      integer, dimension(:) :: n_i, n_pq, n_q
      integer(2), dimension(:) :: quenchers
      integer(1) :: rate_type
      logical(1), dimension(:) :: is_quencher
      integer :: ind, n, k
      real :: t, dt, ft, ann_fac

      rates = tbr
      ann_fac = 0.0

      if (rate_type.eq.1) then
        ind = threadidx%x
        n   = n_i(ind)
      else if (rate_type.eq.2) then
        ind = quenchers(threadidx%x - size(n_i))
        n   = n_pq(ind)
      else if (rate_type.eq.3) then
        ind = quenchers(threadidx%x - (size(n_i) + size(quenchers)))
        n   = n_q(ind)
      end if
      if (t < float(size(pulse)) * dt) then
        ! no generation on a quencher
        if ((rate_type.eq.1).or.&
        (rate_type.eq.2).and.(n.lt.1)) then
          ! hardcode (n_pigments = 24, sigma_ratio = 1.5) for speed
          ! t_index = int(t / dt) + 1
          ft = pulse(int(t / dt) + 1)
          if (((2.5) * n).le.24.0) then
            ! rates(1) = xsec * ft * &
            !   ((n_pigments - (1 + sigma_ratio) * n)/ n_pigments)
            rates(1) = ft * (1 - 0.10416666 * n)
          end if
        end if
      else
        rates(1) = 0.0
      end if
      ! max population on pq/q is 1
      if ((rate_type.ne.2).and.(n_pq(ind).eq.1)) then
        ! if rate_type == 1 but this isn't a quencher, n_pq(ind) = 0
        ! by construction, so this never gets called
        rates(size(rates) - 2) = 0.0_dp
      else if ((rate_type.eq.2).and.(n_q(ind).eq.1)) then
        rates(size(rates) - 2) = 0.0_dp
      end if
      do k = 2, size(rates) - 1
        rates(k) = rates(k) * n
      end do
      ! allow excitons on pre-quencher to annihilate with
      ! excitons on corresponding pool
      ! NB: this is model-dependent!! will need changing
      ! if pq is a CT state, for example
      if (rate_type.ne.3) then
        ! fine for quenching and non-quenching trimers (see above)
        n = n_i(ind) + n_pq(ind)
        ann_fac = (n * (n - 1)) / 2.0_dp
      end if
      ! this is fine because max(n_pq/q(i)) = 1 for all i,
      ! so ann_fac is always 0 on a quencher anyway
      rates(size(rates)) = rates(size(rates)) * ann_fac
    end function get_rates

end module agg

program cuda_agg
  use iso_fortran_env
  use cudafor
  use agg
  implicit none
  integer :: i, j, k, istat, grid_size, n_bins, n_sites, n_quenchers,&
    max_neighbours, rate_size, share_size, sample_offset, max_count
  real :: dt, rho_q, fluence, mu, fwhm, max_time,&
    sigma, t_pulse, binwidth, start_time, end_time, xsec
  type(dim3) :: grid, tBlock
  integer, dimension(:, :), allocatable :: counts
  integer, dimension(:, :), allocatable, device :: counts_d
  integer, dimension(:), allocatable :: neighbours_temp
  integer(2), dimension(:, :), allocatable, device :: neighbours
  real, dimension(:), allocatable :: bins, base_rates, pulse
  real, dimension(:), allocatable, device :: base_rates_d, pulse_d
  character(len=200) :: params_file, rates_file, neighbours_file,&
    counts_file, prefix_long
  character(len=:), allocatable :: file_path, prefix
  type(cudaEvent) :: startEvent, stopEvent
  type(cudaDeviceProp) :: prop

  call get_command_argument(1, params_file)
  open(file=params_file, unit=20)
  read(20, *) n_sites
  read(20, *) max_neighbours
  read(20, *) rho_q
  read(20, *) fluence
  read(20, *) mu
  read(20, *) fwhm
  read(20, *) binwidth
  read(20, *) max_count
  read(20, '(a)') rates_file
  read(20, '(a)') neighbours_file
  close(20)

  ! note - rate_size is set to this because there are a maximum
  ! of five processes that can happen on any given site that aren't
  ! hopping (four on a pool chlorophyll, five on pq, four on q).
  ! hence, max_neighbours + 5 is always a long enough array to hold
  ! every possible rate on every possible site.
  rate_size = max_neighbours + 5
  n_quenchers = int(n_sites * rho_q)

  write(*, '(a, I4)')     "n_sites    = ", n_sites
  write(*, '(a, I1)')     "max neigh  = ", max_neighbours
  write(*, '(a, F8.3)')   "rho_q      = ", rho_q
  write(*, '(a, ES10.3)') "fluence    = ", fluence
  write(*, '(a, F8.3)')   "mu         = ", mu
  write(*, '(a, F8.3)')   "fwhm       = ", fwhm
  write(*, '(a, F8.3)')   "binwidth   = ", binwidth
  write(*, '(a, I8)')     "max count  = ", max_count
  write(*, '(a, a)')      "rate file  = ", rates_file
  write(*, '(a, a)')      "neigh file = ", neighbours_file

  i = scan(rates_file, "/\\", .true.)
  file_path = rates_file(:i)
  write(prefix_long, '(F4.2, a, ES8.2, a)') rho_q, "_", fluence, "_"
  prefix = trim(adjustl(prefix_long))
  write(*, *) "File path = ", file_path
  write(*, *) "Prefix = ", prefix
  write(counts_file, '(a, a, a)') file_path,&
    prefix, "cuda_counts.dat"

  allocate(base_rates(rate_size * (n_sites + 2)))
  open(file=rates_file, unit=20)
  read(20, *) base_rates
  close(20)
  base_rates_d = base_rates

  ! fortran's fine with 0-sized arrays so this is okay
  if (max_neighbours.ne.0) then
    allocate(neighbours_temp(n_sites * max_neighbours))
    allocate(neighbours(n_sites, max_neighbours))
    open(file=neighbours_file, unit=20)
    read(20, *) neighbours_temp
    close(20)
    neighbours = reshape(neighbours_temp, (/n_sites, max_neighbours/))
  else
    allocate(neighbours(n_sites, 1))
    neighbours = 0
  end if

  dt = 1.0
  t_pulse = 2.0_dp * mu
  allocate(pulse_d(int(t_pulse / dt)))
  sigma = fwhm / (2.0_dp * (sqrt(2.0_dp * log(2.0_dp))))
  if ((max_neighbours).gt.0) then
    xsec = (fluence * 1.1E-14) / float(n_sites)
  else
    xsec = (fluence * 1.1E-14)
  end if
  do i = 1, int(t_pulse / dt)
    pulse_d(i) = (xsec) / (sigma * sqrt(2.0_dp * pi)) * &
      exp(-1.0_dp * ((i * dt) - mu)**2 / (sqrt(2.0_dp) * sigma)**2)
  end do

  max_time = 10000.0
  n_bins = int(max_time / binwidth)
  allocate(bins(n_bins))
  do i = 1, size(bins)
    bins(i) = (i - 1) * binwidth
  end do

  istat = cudaGetDeviceProperties(prop, 0)
  write (*, '(/, "Device: ", a)') trim(prop%name)
  write (*, *) "MP count: ", prop%multiProcessorCount

  ! this will probably still waste a few threads but
  tBlock = dim3(32 * ceiling(float((n_sites + 2 * n_quenchers)) / 32), 1, 1)
  write (*, *) "number of threads per block: ", tBlock%x
  ! grid = dim3(16 * 68, 1, 1)
  grid = dim3(256, 1, 1)
  sample_offset = 0

  share_size = (n_sites * (3 * 4 + 1) + n_quenchers * (2) +&
    n_bins * (2 * 4) + size(pulse) * (4) + (4 + 2) * 4)
  ! share_size = 20000
  write (*,*, advance='no') "required shared memory per block: ", share_size
  write (*,*) ". in KiB: ", float(share_size) / 1024

  allocate(counts(4, n_bins))
  allocate(counts_d(4, n_bins))

  counts = 0
  counts_d = counts
  i = 0

  call cpu_time(start_time)

  do while ((maxval(counts(2, :)) + maxval(counts(3, :))).lt.max_count)
    write (*, *) "iteration ", i
    call run_mc<<<grid, tBlock, share_size>>>(counts_d,&
      dt, t_pulse, max_time, binwidth, pulse_d,&
      base_rates_d, neighbours, fluence, n_sites, n_quenchers, n_bins,&
      rate_size, i)

    j = cudaDeviceSynchronize()
    do j = 1, n_bins
      do k = 1,4
        counts(k, j) = counts(k, j) + counts_d(k, j)
      end do
    end do
    write (*,*) "max counts = ", [(maxval(counts(k, :)), k = 1,4)]
    i = i + 1
  end do

  call cpu_time(end_time)
  
  write(*, *) "writing to file"

  open(file=counts_file, unit=20)
  do j = 1, size(bins)
    write(20, '(F10.3)', advance="no") bins(j)
    do k = 1, 4
      write (20, '(4I10)', advance="no") counts(k, j)
    end do
    write(20, *)
  end do
  close(20)

  write(*, *) "time per sample: ", (end_time - start_time) / (i * grid%x)

  stop

end program cuda_agg
